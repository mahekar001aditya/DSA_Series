
class Solution {

    void swap(int arr[], int i, int j) {                 // swap elements at indices i and j
        int temp = arr[i];                               // store first value
        arr[i] = arr[j];                                 // replace with second value
        arr[j] = temp;                                   // restore temp
    }

    public void quickSort(int[] arr, int low, int high) {

        if (low < high) {                                // base condition (more than one element)

            int p = partition(arr, low, high);           // get partition boundary index

            quickSort(arr, low, p);                      // sort left part (IMPORTANT for Hoare)
            quickSort(arr, p + 1, high);                 // sort right part
        }
    }

    private int partition(int[] arr, int low, int high) {

        int pivot = arr[low];                            // Hoare pivot = first element
        int i = low - 1;                                 // left pointer
        int j = high + 1;                                // right pointer

        while (true) {

            do {
                i++;                                     
            } while (arr[i] < pivot);                    // move right until element ≥ pivot

            do {
                j--;                                     
            } while (arr[j] > pivot);                    // move left until element ≤ pivot

            if (i >= j) return j;                        // pointers crossed → return boundary index

            swap(arr, i, j);                             // swap misplaced elements
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////

Quick Sort
Implement Quick Sort, a Divide and Conquer algorithm, to sort an array, arr[] in ascending order.
Given an array arr[], with starting index low and ending index high, complete the functions partition() and quickSort().
Use the last element as the pivot, so that all elements less than or equal to the pivot come before it, and elements greater than the pivot follow it.

Note: low and high are inclusive.

Examples:

Input: arr[] = [4, 1, 3, 9, 7]
Output: [1, 3, 4, 7, 9]
Explanation: After sorting, all elements are arranged in ascending order.

Input: arr[] = [2, 1, 6, 10, 4, 1, 3, 9, 7]
Output: [1, 1, 2, 3, 4, 6, 7, 9, 10]
Explanation: Duplicate elements (1) are retained in sorted order.

Input: arr[] = [5, 5, 5, 5]
Output: [5, 5, 5, 5]
Explanation: All elements are identical, so the array remains unchanged.

Constraints:
1 ≤ arr.size() ≤ 105
1 ≤ arr[i] ≤ 105

