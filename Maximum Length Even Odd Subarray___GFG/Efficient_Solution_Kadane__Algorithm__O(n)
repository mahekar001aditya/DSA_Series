
int maxEvenOdd(int arr[], int n) {
    int res = 1;
    int curr = 1;
    
    for(int i = 1; i < n; i++) {
        // If parity alternates (Even/Odd or Odd/Even)
        if((arr[i] % 2 == 0 && arr[i-1] % 2 != 0) || 
           (arr[i] % 2 != 0 && arr[i-1] % 2 == 0)) {
                curr++;                       // Increment current subarray length
                res = Math.max(res, curr);    // Update global max if curr is larger
        }
        else {
              curr = 1;                       // Reset: found same parity (E,E or O,O)
        }
    }
    return res;
}
   
/////////////////////////////////////////////////////////////////////////

[5, 10, 20, 6, 3, 8]           res = 1


i=1: curr= 2 → res= 2 
i=2: curr= 1 
i=3: curr= 1 
i=4: curr= 2 
i=5: curr= 3 → res= 3  

Final res = 3


/////////////////////////////////////////////////////////////////////////


Length of the longest alternating even odd subarray:

Given an array a[] of N integers, the task is to find the length of the longest Alternating Even Odd subarray present in the array. 

Examples: 

Input: a[] = {1, 2, 3, 4, 5, 7, 9} 
Output: 5 
Explanation: 
The subarray {1, 2, 3, 4, 5} has alternating even and odd elements.

Input: a[] = {1, 3, 5} 
Output: 0 
Explanation: 
There is no such alternating sequence possible. 
