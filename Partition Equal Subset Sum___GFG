
class Solution {
    static boolean equalPartition(int arr[]) {

        int sum = 0;                           // Total sum of array
        for (int n : arr) {                     // Traverse array elements
            sum += n;                           // Add element to sum
        }

        if (sum % 2 != 0)                       // If sum is odd
            return false;                       // Cannot partition equally

        int target = sum / 2;                   // Desired subset sum

        boolean[] bn = new boolean[target + 1];  // DP array for sums
        bn[0] = true;                           // Sum 0 always possible

        for (int i : arr) {                     // Process each number

            for (int j = target; j >= i; j--) { // Backward traversal

                if (bn[j - i]) {                // If smaller sum exists
                    bn[j] = true;               // Mark new sum achievable
                }
            }
        }

        return bn[target];                       // Final check
    }
}
//////////////////////////////////////////////////////////////////////////
arr = [1, 5, 11, 5]
target = 11
bn[0] = true
âœ… Full Iteration Trace (i, j, j-i, result)
ðŸ”¹ i = 1
j = 11 â†’ j-i = 10 â†’ bn[10] = false â†’ no change
j = 10 â†’ j-i = 9  â†’ bn[9]  = false â†’ no change
j = 9  â†’ j-i = 8  â†’ bn[8]  = false â†’ no change
j = 8  â†’ j-i = 7  â†’ bn[7]  = false â†’ no change
j = 7  â†’ j-i = 6  â†’ bn[6]  = false â†’ no change
j = 6  â†’ j-i = 5  â†’ bn[5]  = false â†’ no change
j = 5  â†’ j-i = 4  â†’ bn[4]  = false â†’ no change
j = 4  â†’ j-i = 3  â†’ bn[3]  = false â†’ no change
j = 3  â†’ j-i = 2  â†’ bn[2]  = false â†’ no change
j = 2  â†’ j-i = 1  â†’ bn[1]  = false â†’ no change
j = 1  â†’ j-i = 0  â†’ bn[0]  = true  â†’ bn[1] = true âœ…
ðŸ”¹ i = 5
j = 11 â†’ j-i = 6 â†’ bn[6] = false â†’ no change
j = 10 â†’ j-i = 5 â†’ bn[5] = false â†’ no change
j = 9  â†’ j-i = 4 â†’ bn[4] = false â†’ no change
j = 8  â†’ j-i = 3 â†’ bn[3] = false â†’ no change
j = 7  â†’ j-i = 2 â†’ bn[2] = false â†’ no change
j = 6  â†’ j-i = 1 â†’ bn[1] = true  â†’ bn[6] = true âœ…
j = 5  â†’ j-i = 0 â†’ bn[0] = true  â†’ bn[5] = true âœ…
ðŸ”¹ i = 11
j = 11 â†’ j-i = 0 â†’ bn[0] = true â†’ bn[11] = true âœ…

ðŸŽ¯ Target achieved

ðŸ”¹ i = 5 (last element)
j = 11 â†’ j-i = 6 â†’ bn[6] = true  â†’ bn[11] already true
j = 10 â†’ j-i = 5 â†’ bn[5] = true  â†’ bn[10] = true âœ…
j = 9  â†’ j-i = 4 â†’ bn[4] = false â†’ no change
j = 8  â†’ j-i = 3 â†’ bn[3] = false â†’ no change
j = 7  â†’ j-i = 2 â†’ bn[2] = false â†’ no change
j = 6  â†’ j-i = 1 â†’ bn[1] = true  â†’ bn[6] already true
j = 5  â†’ j-i = 0 â†’ bn[0] = true  â†’ bn[5] already true

////////////////////////////////////////////////////////////////////////////////////////////////

Partition Equal Subset Sum
Given an array arr[], determine if it can be partitioned into two subsets such that the sum of elements in both parts is the same.

Note: Each element must be in exactly one subset.

Examples:

Input: arr = [1, 5, 11, 5]
Output: true
Explanation: The two parts are [1, 5, 5] and [11].

Input: arr = [1, 3, 5]
Output: false
Explanation: This array can never be partitioned into two such parts.

Constraints:
1 â‰¤ arr.size â‰¤ 100
1 â‰¤ arr[i] â‰¤ 200

