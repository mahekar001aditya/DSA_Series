

class Solution {
    public int josephus(int n, int k) {

        // Base case:
        // If only one person is left, that person is the winner.
        // Using 1-based indexing, so return 1.

        if(n == 1){
            return 1;
        }

        // Recursive case:
        // 1. Solve Josephus for (n-1) people
        // 2. Shift the position by (k-1) because every k-th person is eliminated
        // 3. Use modulo n to keep position within range
        // 4. Add 1 to convert back to 1-based indexing

        return (josephus(n-1, k) + k - 1) % n + 1;
    }
}


////////////////////////////////////////////////////////////////////////////////////

J(n,k) = (J(n−1,k) + k − 1) % n + 1      

jos(1,3) = 1

jos(2,3) = (1 + 3 − 1) % 2 + 1
         = 3 % 2 + 1
         = 1 + 1
         = 2

jos(3,3) = (2 + 3 − 1) % 3 + 1
         = 4 % 3 + 1
         = 1 + 1
         = 2

jos(4,3) = (2 + 3 − 1) % 4 + 1
         = 4 % 4 + 1
         = 0 + 1
         = 1

jos(5,3) = (1 + 3 − 1) % 5 + 1
         = 3 % 5 + 1
         = 3 + 1
         = 4
 
////////////////////////////////////////////////////////////////////////////////////

Josephus problem:
You are playing a game with n people standing in a circle, numbered from 1 to n. Starting from person 1, every kth person is eliminated in a circular fashion. The process continues until only one person remains.
Given integers n and k, return the position (1-based index) of the person who will survive.

Examples :

Input: n = 5, k = 2
Output: 3
Explanation: Firstly, the person at position 2 is killed, then the person at position 4 is killed, then the person at position 1 is killed. 
Finally, the person at position 5 is killed. So the person at position 3 survives. 

Input: n = 7, k = 3
Output: 4
Explanation: The elimination order is 3 → 6 → 2 → 7 → 5 → 1, and the person at position 4 survives.

Constraints:
1 ≤ n, k ≤ 500

